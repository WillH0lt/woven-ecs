import {
  addComponent,
  type ComponentSchema,
  type Context,
  createEntity,
  type EntityId,
  EventType,
  hasComponent,
  removeComponent,
} from '@woven-ecs/core'
import type { Adapter } from '../Adapter'
import { Synced } from '../components/Synced'
import { Origin } from '../constants'
import { diffFields } from '../diff'
import type { AnyEditorComponentDef } from '../EditorComponentDef'
import type { AnyEditorSingletonDef } from '../EditorSingletonDef'
import { type ComponentData, type Mutation, type Patch, SINGLETON_STABLE_ID } from '../types'

export interface EcsAdapterOptions {
  components: AnyEditorComponentDef[]
  singletons: AnyEditorSingletonDef[]
}

/**
 * ECS bridge that converts ECS events to mutations and vice versa.
 *
 * - pull(): Reads ECS events and produces mutations with stable ID keys.
 * - push(): Receives mutations and applies them to the ECS context.
 *
 * Circular updates are avoided by only reading events that occurred
 * between when push() finishes and the next pull() starts. Events
 * generated by push() writing to the ECS are skipped by advancing
 * the event index after push completes.
 */
export class EcsAdapter implements Adapter {
  ctx!: Context
  private components: AnyEditorComponentDef[]
  private singletons: AnyEditorSingletonDef[]

  /** componentId -> definition (built during initialize) */
  private componentMap = new Map<number, AnyEditorComponentDef | AnyEditorSingletonDef>()

  /** component name -> definition */
  private componentsByName = new Map<string, AnyEditorComponentDef | AnyEditorSingletonDef>()

  /** stable UUID -> ECS entity ID */
  private stableIdToEntity = new Map<string, EntityId>()

  /** ECS entity ID -> stable UUID */
  private entityToStableId = new Map<EntityId, string>()

  /** Previously synced state for computing diffs */
  private prevState: Record<string, ComponentData> = {}

  /** Event buffer read position */
  private eventIndex = 0

  private initialized = false

  constructor(options: EcsAdapterOptions) {
    this.components = options.components
    this.singletons = options.singletons
  }

  async init(): Promise<void> {
    // No async initialization needed
  }

  /**
   * Build component lookup maps on first pull.
   */
  private ensureInitialized(): void {
    if (this.initialized) return
    this.initialized = true

    const ctx = this.ctx
    for (const comp of [...this.components, ...this.singletons]) {
      if (comp.sync === 'none') continue

      const componentId = comp._getComponentId(ctx)
      this.componentMap.set(componentId, comp)
      this.componentsByName.set(comp.name, comp)
    }
  }

  /**
   * Read ECS events since the last push and convert to mutations.
   * Keys use stable IDs: "uuid/componentName" or "SINGLETON/singletonName".
   */
  pull(): Mutation[] {
    this.ensureInitialized()
    const ctx = this.ctx

    const { events } = ctx.eventBuffer.readEvents(this.eventIndex)

    if (events.length === 0) return []

    const docPatch: Patch = {}
    const ephPatch: Patch = {}
    const localPatch: Patch = {}

    const getPatchTarget = (sync: string | undefined): Patch => {
      if (sync === 'ephemeral') return ephPatch
      if (sync === 'local') return localPatch
      return docPatch
    }

    for (const event of events) {
      const { entityId, eventType, componentId } = event

      // Handle entity removal — emit deletion patches for all tracked components
      if (eventType === EventType.REMOVED) {
        const stableId = this.entityToStableId.get(entityId)

        if (!stableId) continue

        const prefix = `${stableId}/`
        for (const key of Object.keys(this.prevState)) {
          if (key.startsWith(prefix)) {
            const compName = key.slice(prefix.length)
            const compDef = this.componentsByName.get(compName)
            const target = getPatchTarget(compDef?.sync)
            target[key] = { _exists: false }
            this.prevState[key] = { _exists: false }
          }
        }

        this.stableIdToEntity.delete(stableId)
        this.entityToStableId.delete(entityId)
        continue
      }

      const componentDef = this.componentMap.get(componentId)

      if (!componentDef) continue

      // exclude unsynced entities
      if (!componentDef.isSingleton && !hasComponent(ctx, entityId, Synced, false)) continue

      const synced = Synced.read(ctx, entityId)

      // Resolve stable ID
      let stableId: string
      if (componentDef.isSingleton) {
        stableId = SINGLETON_STABLE_ID
      } else {
        stableId = synced.id
        this.stableIdToEntity.set(stableId, entityId)
        this.entityToStableId.set(entityId, stableId)
      }

      const key = `${stableId}/${componentDef.name}`
      const patch = getPatchTarget(componentDef.sync)

      switch (eventType) {
        case EventType.COMPONENT_ADDED: {
          if (componentDef.isSingleton) continue
          const raw = componentDef.snapshot(ctx, entityId)
          const data = this.translateRefsOutbound(componentDef, raw)
          patch[key] = data as ComponentData
          this.prevState[key] = { ...data }
          break
        }

        case EventType.COMPONENT_REMOVED: {
          if (componentDef.isSingleton) continue
          patch[key] = { _exists: false }
          this.prevState[key] = { _exists: false }
          break
        }

        case EventType.CHANGED: {
          const raw = componentDef.isSingleton
            ? (componentDef as AnyEditorSingletonDef).snapshot(ctx)
            : componentDef.snapshot(ctx, entityId)
          const data = this.translateRefsOutbound(componentDef, raw)

          const prev = this.prevState[key] ?? { _exists: false }
          const changes = diffFields(prev, data)
          if (!changes) continue

          patch[key] = changes as ComponentData
          this.prevState[key] = { ...data }
          break
        }
      }
    }

    const results: Mutation[] = []
    if (Object.keys(docPatch).length > 0) {
      results.push({
        patch: docPatch,
        origin: Origin.ECS,
        syncBehavior: 'document',
      })
    }
    if (Object.keys(ephPatch).length > 0) {
      results.push({
        patch: ephPatch,
        origin: Origin.ECS,
        syncBehavior: 'ephemeral',
      })
    }
    if (Object.keys(localPatch).length > 0) {
      results.push({
        patch: localPatch,
        origin: Origin.ECS,
        syncBehavior: 'local',
      })
    }
    return results
  }

  /**
   * Apply mutations to the ECS context.
   * Self-originated mutations (origin ECS) are skipped — the ECS world
   * already contains those changes from the current frame.
   * After applying, advances the event index to skip any events
   * generated by these writes.
   */
  push(mutations: Mutation[]): void {
    const ctx = this.ctx
    for (const { patch, origin } of mutations) {
      if (origin === Origin.ECS) continue

      // Pass 1: Ensure entities exist for all new components so refs can resolve
      for (const [key, value] of Object.entries(patch)) {
        if (!value._exists) continue
        const sepIndex = key.indexOf('/')
        const stableId = key.slice(0, sepIndex)
        if (stableId === SINGLETON_STABLE_ID) continue

        if (!this.stableIdToEntity.has(stableId)) {
          const entityId = createEntity(ctx)
          addComponent(ctx, entityId, Synced, { id: stableId })
          this.stableIdToEntity.set(stableId, entityId)
          this.entityToStableId.set(entityId, stableId)
        }
      }

      // Pass 2: Apply component data (refs can now resolve)
      for (const [key, value] of Object.entries(patch)) {
        const sepIndex = key.indexOf('/')
        const stableId = key.slice(0, sepIndex)
        const componentName = key.slice(sepIndex + 1)

        const componentDef = this.componentsByName.get(componentName)
        if (!componentDef) continue

        if (stableId === SINGLETON_STABLE_ID) {
          if (value._exists === false) continue // Singletons can't be removed
          ;(componentDef as AnyEditorSingletonDef).patch(ctx, value as any)
          this.prevState[key] = {
            ...this.prevState[key],
            ...value,
          }
          continue
        }

        // Entity component
        const entityId = this.stableIdToEntity.get(stableId)
        if (entityId === undefined) continue

        if (value._exists === false) {
          // Remove component
          if (hasComponent(ctx, entityId, componentDef as AnyEditorComponentDef, false)) {
            removeComponent(ctx, entityId, componentDef as AnyEditorComponentDef)
          }
          this.prevState[key] = { _exists: false }
        } else if (value._exists) {
          // Add component (entity already created in pass 1)
          const translated = this.translateRefsInbound(componentDef, value)

          if (hasComponent(ctx, entityId, componentDef as AnyEditorComponentDef, false)) {
            ;(componentDef as AnyEditorComponentDef).copy(ctx, entityId, translated as any)
          } else {
            addComponent(ctx, entityId, componentDef as AnyEditorComponentDef, translated as any)
          }
          this.prevState[key] = { ...value }
        } else {
          // Partial update — only touch specified fields
          if (entityId !== undefined && hasComponent(ctx, entityId, componentDef as AnyEditorComponentDef, false)) {
            const translated = this.translateRefsInbound(componentDef, value)
            ;(componentDef as AnyEditorComponentDef).patch(ctx, entityId, translated as any)
            this.prevState[key] = { ...this.prevState[key], ...value }
          }
        }
      }
    }

    // Advance past events generated by our writes
    this.eventIndex = ctx.eventBuffer.getWriteIndex()
  }

  // ─── Ref Translation ─────────────────────────────────────────────────────────

  /**
   * Translate ref fields from entityIds to stableIds for outbound mutations.
   * Returns a new object with refs converted to UUIDs (or null if not synced).
   */
  private translateRefsOutbound(
    componentDef: AnyEditorComponentDef | AnyEditorSingletonDef,
    data: Record<string, unknown>,
  ): Record<string, unknown> {
    const schema = componentDef.schema as ComponentSchema
    let hasRefs = false

    for (const fieldName in schema) {
      if (schema[fieldName].def.type === 'ref') {
        hasRefs = true
        break
      }
    }

    if (!hasRefs) return data

    const result = { ...data }
    for (const fieldName in schema) {
      if (schema[fieldName].def.type === 'ref' && result[fieldName] != null) {
        const entityId = result[fieldName] as EntityId
        result[fieldName] = this.entityToStableId.get(entityId) ?? null
      }
    }
    return result
  }

  /**
   * Translate ref fields from stableIds to entityIds for inbound mutations.
   * Returns a new object with refs converted to entityIds (or null if not found).
   */
  private translateRefsInbound(
    componentDef: AnyEditorComponentDef | AnyEditorSingletonDef,
    data: Record<string, unknown>,
  ): Record<string, unknown> {
    const schema = componentDef.schema as ComponentSchema
    let hasRefs = false

    for (const fieldName in schema) {
      if (schema[fieldName].def.type === 'ref') {
        hasRefs = true
        break
      }
    }

    if (!hasRefs) return data

    const result = { ...data }
    for (const fieldName in schema) {
      if (schema[fieldName].def.type === 'ref' && result[fieldName] != null) {
        const stableId = result[fieldName] as string
        result[fieldName] = this.stableIdToEntity.get(stableId) ?? null
      }
    }
    return result
  }

  close(): void {
    // No resources to clean up
  }
}
